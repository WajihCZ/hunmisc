diff -u ../../../1/liblinear-1.93/python/liblinear.py ./liblinear.py
--- ../../../1/liblinear-1.93/python/liblinear.py	2013-01-21 19:03:19.000000000 +0100
+++ ./liblinear.py	2013-11-12 18:54:09.080091110 +0100
@@ -10,7 +10,7 @@
 	if sys.platform == 'win32':
 		liblinear = CDLL(path.join(dirname, r'..\windows\liblinear.dll'))
 	else:
-		liblinear = CDLL(path.join(dirname, '../liblinear.so.1'))
+		liblinear = CDLL(path.join(dirname, 'liblinear/liblinear.so.1'))
 except:
 # For unix the prefix 'lib' is not considered.
 	if find_library('linear'):
@@ -47,14 +47,36 @@
 	def __str__(self):
 		return '%d:%g' % (self.index, self.value)
 
+def gen_feature_nodearray_from_array(xi, feature_max=None, issparse=True):
+	values = xi
+	if feature_max:
+		assert(isinstance(feature_max, int))
+		values = filter(lambda x: x[0] <= feature_max, values)
+	if issparse: 
+		values = filter(lambda x: x[1] != 0, values)
+
+	values = sorted(values, key=lambda x: x[0])
+	ret = (feature_node * (len(values)+2))()
+	ret[-1].index = -1 # for bias term
+	ret[-2].index = -1
+	for idx, (feature, value) in enumerate(values):
+		ret[idx].index = feature
+		ret[idx].value = value
+	max_idx = 0
+	if values: 
+		max_idx = values[-1][0]
+	return ret, max_idx
+
 def gen_feature_nodearray(xi, feature_max=None, issparse=True):
 	if isinstance(xi, dict):
 		index_range = xi.keys()
 	elif isinstance(xi, (list, tuple)):
 		xi = [0] + xi  # idx should start from 1
 		index_range = range(1, len(xi))
+	elif isinstance(xi, Array):
+		return gen_feature_nodearray_from_array(xi, feature_max, issparse)
 	else:
-		raise TypeError('xi should be a dictionary, list or tuple')
+		raise TypeError('xi should be a dictionary, list, tuple or ctypes.Array')
 
 	if feature_max:
 		assert(isinstance(feature_max, int))
@@ -79,20 +101,35 @@
 	_types = [c_int, c_int, POINTER(c_double), POINTER(POINTER(feature_node)), c_double]
 	_fields_ = genFields(_names, _types)
 
-	def __init__(self, y, x, bias = -1):
+	def __init__(self, y=None, x=None, bias = -1):
+		self.__init_raw__(bias)
+		if x is None and y is None:
+			self.finished = False
+			return
+
 		if len(y) != len(x) :
 			raise ValueError("len(y) != len(x)")
-		self.l = l = len(y)
 		self.bias = -1
 
-		max_idx = 0
-		x_space = self.x_space = []
-		for i, xi in enumerate(x):
-			tmp_xi, tmp_idx = gen_feature_nodearray(xi)
-			x_space += [tmp_xi]
-			max_idx = max(max_idx, tmp_idx)
-		self.n = max_idx
+		for i in xrange(len(x)):
+			self.add_event(y[i], x[i])
 
+		self.set_bias(bias)
+	
+	def __init_raw__(self, bias):
+		self.bias = bias
+		self.x_space = []
+		self.y_ = []
+	
+	def add_event(self, y, x):
+		tmp_xi, tmp_idx = gen_feature_nodearray(x)
+		self.x_space += [tmp_xi]
+		self.max_idx = max(self.max_idx, tmp_idx)
+		self.y_ += y
+	
+	def finish(self):
+		self.l = len(self.y_)
+		self.n = self.max_idx
 		self.y = (c_double * l)()
 		for i, yi in enumerate(y): self.y[i] = y[i]
 
@@ -100,6 +137,7 @@
 		for i, xi in enumerate(self.x_space): self.x[i] = xi
 
 		self.set_bias(bias)
+		self.finished = True
 
 	def set_bias(self, bias):
 		if self.bias == bias:
